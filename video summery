important topics
----------------------
Analysis of algorthm
Arrays
sorting algorthm
linked list
stack
queue
more sorting algorthm
recursion
binary tree
hashtable
heap
=====================
Euclid's Algorthm
---------------------
how to find GCD?
given m and n , m>n
1)m%n==r
2)if r==0, GCD=n
3)m=n, n=r
4)repeat 1 one to 2
========================
why algorthms
----------------------
idea about running time
can make improvment
hardwere requrment
feesible or not
==========================
why data structure
----------------------------
to store the data in systamatic manner
=======================================
Analysis of algorthm
----------------------
time complexity
space complexity
=======================
types of tome complexity
--------------------------
best case
worst case
avarage case
worst is used commen
============================
RAM model computation
----------------------------
assumptions we follow in calcualting time complexity
infinit memmory
operation takes unit time
memmory acces take unit time
data can acces from both disk and ram but here we assume data is acces rom the ram
===================================================================================
Bubble sort algorthm
----------------------
for(int i=0;i<l-1;i++){
            for(int j=0;j<l-1-i;j++){
                if(a[j]>a[j+1]){
                    temp=a[j];
                    a[j]=a[j+1];
                    a[j+1]=temp;
                }
            }
        }
        
 ========================
 Big O natation
 --------------
 O(n^2)={f(n):there exist positive constands c and n0 such that 0<f(n)<c(n0 ^ 2) for all n>n0}
 ie : On^2 is set of functions where positive constands c and n0 such that 0<f(n)<c(n0 ^ 2) for all n>n0
 O (g(n)) = { f(n) : there exist positive constants c and ng such that 0 <f(n)< cg(n) for all n= no - this is also sam eas above n^2 replcaed by g(n)
 =======================================================================================================================================================
 Time complexity order
 -----------------------
 logn<n^1/2<n<nlogn<n^2<n^3<2^n<n!
 ================================
 Selection Sort
 --------------
 for(int i=0;i<a.length-1;i++){
            int minIndex=i;
            for(int j=i+1;j<a.length;j++){
                if(a[minIndex]>a[j]){
                    minIndex=j;
                }
            }
            int temp=a[minIndex];
            a[minIndex]=a[i];
            a[i]=temp;
        }
 =========================================
 insertion Sort
 --------------
  int j=0;
        for(int i=0;i<a.length;i++){
            int current=a[i];
            for(j=i-1;j>=0;j--){
                if(current<a[j]){
                    a[j+1]=a[j];
                }
            }
            a[j+1]=current;

        }
======================================
comparison insertion sort/bubble sort/selection sort
-----------------------------------------------------
insertion sort| bubble sort| selection sor|
------------------------------------------
reletively    |inefficient |good than     |
good          |            |bubble sort   |
for small     |            |--------------|
number of     |            |running time  |
items         |            |indipendent of|
---------------            |ordering      |
 relatively   |            |of element    |
 good for     |            |              |
 partiallt    |            |              |
 sorted array |            |              |
 ------------------------------------------
 ===========================================
 stable/unstable sort
 ------------------------
 3,5,2,1,5',10 - unsorted ayyay
 1,2,3,5,5',10 - stable sort
 1,2,3,5',5,10 - unstable sort
 why? think!!!(https://www.linkedin.com/learning/introduction-to-data-structures-algorithms-in-java/stable-vs-unstable-sorts?autoplay=true&resume=false&u=2007516)
 ==================================================================================================================================================================
 serching for a elemnt in an un-ordered array - O(n)
 delete a elemnt in an un-ordered array - O(n)
 serching for a elemnt in an ordered array - O(logn)
 inserting in an ordered array - search for the loc + move the rest - O(n)
 deleting in an  ordered array - search for the item + move the rest - O(n)
 deleting from head - o(1)
 inserting to head - O(1)
 
===========================================================================
///////doubly linked list and sort in in limkked list need s look one more tome
=====================
stack
-----
push : insert to top
pop : delete from top return it
peek : return the top
LIFO
===================================
ADT
----
arrays and linked list are real data structure ie, it reperesends in physical memmory as such
but stack and queue are ABSTRACT DATA TYPE ie, these are implimented from raray sor linked list
================================================================================================
Queue
-----
head
tail
enqueue: inserting into queue from tail
dequeue: removig from queue from head

			   ............................
romoving<--head                            tail<--inserting
			   ............................
		
peek: retun the element at head
if we remove from queue the element at head index will remove <1><2><3><4><5><6><7><8><9><10><11><12><13>
                                                               H                                       R
                                                              <><2><3><4><5><6><7><8><9><10><11><12><13>
															     H                                    R
															  <><><3><4><5><6><7><8><9><10><11><12><13>
															       H                                 R
now if we want to enqueue new element,actually we have spece in queue, but tail need to change from current position to here (TAIN INDEX-HEADINDEX<LENGTH OF ARRAY)(12-3<13) IN THIS CASE WILL MOVE TAIL TO "0"th INDEX AND WE ADD ELEMENT FROM THERE THIS situation is called circular queue(tail again back to 0 th index)
                                                                   0 1 2  3  4  5  6  7  8  9   10  11  12
                                                                  <><><3><4><5><6><7><8><9><10><11><12><13>
															       T   H       
=========================================================================================================================										De Queue - double ended queue
-----------------------------
not using in coding beacuse of the complexity
allows remove/add from both tail and head
insert left, insert right, delete left, delete right
https://www.softwaretestinghelp.com/deque-in-java/
================================================================
priority queue will learn after heap
================================================
 
 
 
 



